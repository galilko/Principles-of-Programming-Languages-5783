Module: project-11
Synopsis: 
Author: Gal Gabay & Nerya Barkasa
Copyright: 

/**
 * recursive top-down parser
 *
 * Effects the actual compilation output.
 * 1.Gets its input from a JackTokenizer and emits its parsed structure into an output file/stream.
 * 2.The output is generated by a series of compile_xxx ( ) routines, one for every syntactic element xxx of the Jack grammar.
 * 3.The contract between these routines is that each compile_xxx ( ) routine should read the syntactic construct xxx from the input,
 * advance ( ) the tokenizer exactly beyond xxx, and output the parsing of xxx.
 * Thus, compile_xxx ( ) may only be called if indeed xxx is the next syntactic element of the input.
 *
 * In the first version of the compiler, described in chapter 10, this module emits a structured printout of the code, wrapped in XML tags.
 * In the final version of the compiler, described in chapter 11, this module generates executable VM code.
 * In both cases, the parsing logic and module API are exactly the same.
 */
define class <compilation-engine> (<object>)
    slot vmWriter :: <vm-writer>;
    slot tokenizer :: <jack-tokenizer>;
    slot symbolTable :: <symbol-table>;
    slot labelIndex :: <integer>, init-value: 0;
    slot currentClass :: <string>;
    slot currentSubroutine :: <string>;
    slot indentation :: <integer>, init-value: 0;
    slot width :: <string>, init-value: "  ";
end class;

/**
 * Creates a new compilation engine with the given input and output.
 * The next routine called must be compileClass()
 * @param inFile
 * @param outFile
 */
define function create-compilation-engine
(engine :: <compilation-engine>, in-file :: <file-stream>, out-file :: <file-stream>)
    engine.labelIndex := 0;
    engine.tokenizer := make(<jack-tokenizer>);
    engine.vmWriter := make(<vm-writer>);
    engine.symbolTable := make(<symbol-table>);
    generate-tokens(engine.tokenizer, in-file);
    create-writer(engine.vmWriter, out-file);
    init-symbol-table(engine.symbolTable);
end function;

    //-------------------compile_xxx ( ) routines - recursive descent-------------------//

    /**
     * Compiles a type
     */
define function compileType
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileType");
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        let key = getKeyword(engine.tokenizer);

        if ((type == #"KEYWORD" & (key == #"INT" | key == #"CHAR" | key == #"BOOLEAN")) | (type == #"IDENTIFIER"))
            printCloseTagFunction(engine, "compileType");
            return (engine.tokenizer.currentToken);
        else
            throwError(engine, "int|char|boolean|className");
            printCloseTagFunction(engine, "compileType");
            return();
        end;
    end;
end function;

    /**
     * Complies a complete class
     * class: 'class' className "{" classVarDec* subroutineDec* "}"
     */
define function compileClass
(engine :: <compilation-engine>)
    //class
    block (return)
        printOpenTagFunction(engine, "compileClass");
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type ~= #"KEYWORD" | getKeyword(engine.tokenizer) ~= #"CLASS")
             throwError(engine, "class");
             return();
        end if;
        //className
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type ~= #"IDENTIFIER")
            throwError(engine, "className");
            return();
        end if;
        engine.currentClass := getIdentifier(engine.tokenizer);
        //"{"
        requireSymbol(engine, "{");
        //classVarDec* subroutineDec*
        compileClassVarDec(engine);
        compileSubroutine(engine);
    
        //"}"
        requireSymbol(engine, "}");
        if (hasMoreTokens(engine.tokenizer))
            format-out("Unexpected tokens");
            return();
        end if;
        printCloseTagFunction(engine, "compileClass");

        //save file
        close-file(engine.vmWriter);
    end block;
end function;


    /**
     * Compiles a static declaration or a field declaration
     * classVarDec ('static'|'field') type varName (','varName)* ';'
     */
define function compileClassVarDec
(engine :: <compilation-engine>)
    //first determine whether there is a classVarDec, nextToken is } or start subroutineDec
    block(return)
        printOpenTagFunction(engine, "compileClassVarDec");
        advance(engine.tokenizer);
        //next is a "}" or next is subroutineDec
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        let key = getKeyword(engine.tokenizer);
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), "}"))
            pointerBack(engine.tokenizer);
            printCloseTagFunction(engine, "compileClassVarDec");
            return();
    
        //next is start subroutineDec or classVarDec, both start with keyword
        elseif (type ~= #"KEYWORD")
            throwError(engine, "keyword");
            return();

        //next is subroutineDec
        elseif (key == #"CONSTRUCTOR" | key == #"FUNCTION" | key == #"METHOD")
            pointerBack(engine.tokenizer);
            printCloseTagFunction(engine, "compileClassVarDec");
            return();
        end;


        //classVarDec exists
        let key = getKeyword(engine.tokenizer);
        if (key ~= #"STATIC" & key ~= #"FIELD")
            throwError(engine, "static or field");
            return();
        end if;

        let kind = #"NONE";
        select (key)
            #"STATIC" => kind := #"STATIC";
            #"FIELD" => kind := #"FIELD";
        end select;

        //type
        let stringType = compileType(engine);
        let name :: <string> = "";
        //at least one varName
        let flag = #t;
        while (flag)
            //varName
            advance(engine.tokenizer);
            let type :: <token-type> = engine.tokenizer.currentTokenType;

            if (type ~= #"IDENTIFIER")
                throwError(engine, "identifier");
                return();
            end if;
            name := engine.tokenizer.currentToken;

            defineId(engine.symbolTable, name,stringType,kind);

            //',' or ';'
            advance(engine.tokenizer);
            let type :: <token-type> = engine.tokenizer.currentTokenType;
            let symbol = getSymbol(engine.tokenizer);
            if (type ~= #"SYMBOL" | (~string-equal?(symbol,",") & ~string-equal?(symbol,";")))
                throwError(engine, "',' or ';'");
                return();
            end if;
            if (string-equal? (getSymbol(engine.tokenizer), ";"))
                flag := #f;
            end if;
        end while;

        compileClassVarDec(engine);
        printCloseTagFunction(engine, "compileClassVarDec");
    end block;
end function;


/**
 * Compiles a complete method function or constructor
 */
define function compileSubroutine
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileSubroutine");
        //determine whether there is a subroutine, next can be a "}"
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        
        //next is a "}"
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), "}"))
            pointerBack(engine.tokenizer);
            printCloseTagFunction(engine, "compileSubroutine");
            return();
        end if;

        //start of a subroutine
        let key = getKeyword(engine.tokenizer);

        if (type ~= #"KEYWORD" | (key ~= #"CONSTRUCTOR" & key ~= #"FUNCTION" & key ~= #"METHOD"))
            throwError(engine, "constructor|function|method");
            return();
        end if;

        //reset symbol table of subroutine
        startSubroutine(engine.symbolTable);
        //for method this is the first argument
        if (key == #"METHOD")
            defineId(engine.symbolTable, "this", engine.currentClass, #"ARG");
        end if;
        

        advance(engine.tokenizer);
        //'void' or type
        type := engine.tokenizer.currentTokenType;
        if (type == #"KEYWORD" & getKeyword(engine.tokenizer) == #"VOID")
            
        else
            pointerBack(engine.tokenizer);
            compileType(engine);
        end;

        //subroutineName which is a identifier
        advance(engine.tokenizer);
        type := engine.tokenizer.currentTokenType;
        if (type ~= #"IDENTIFIER")
            throwError(engine, "subroutineName");
            return();
        end if;

        engine.currentSubroutine := engine.tokenizer.currentToken;

        //'('
        requireSymbol(engine, "(");
        //parameterList
        compileParameterList(engine);
        //')'
        requireSymbol(engine, ")");
        //subroutineBody
        compileSubroutineBody(engine,key);
        compileSubroutine(engine);
        printCloseTagFunction(engine, "compileSubroutine");
    end;
end function;

    /**
     * Compiles the body of a subroutine
     * "{"  varDec* statements "}"
     */
    define function compileSubroutineBody(engine :: <compilation-engine>, key)
        printOpenTagFunction(engine, "compileSubroutineBody");
        //"{"
        requireSymbol(engine, "{");
        //varDec*
        compileVarDec(engine);
        //write VM function declaration
        writeFunctionDec(engine, key);
        //statements
        compileStatement(engine);        
        //"}"
        requireSymbol(engine, "}");
        printCloseTagFunction(engine, "compileSubroutineBody");
    end function;


    define function writeFunctionDec(engine :: <compilation-engine>, key)
        printOpenTagFunction(engine, "writeFunctionDec");
        write-function(engine.vmWriter, currentFunction(engine), varCount(engine.symbolTable, #"VAR"));
        //METHOD and CONSTRUCTOR need to load this pointer
        if (key == #"METHOD")
            //A Jack method with k arguments is compiled into a VM function that operates on k + 1 arguments.
            //The first argument (argument number 0) always refers to the this object.
            write-push(engine.vmWriter, "argument", 0);
            write-pop(engine.vmWriter, "pointer",0);
        elseif (key == #"CONSTRUCTOR")
            //A Jack constructor with k arguments is compiled into a VM function that operates on k arguments.
            write-push(engine.vmWriter, "constant", varCount(engine.symbolTable, #"FIELD"));
            write-call(engine.vmWriter, "Memory.alloc", 1);
            write-pop(engine.vmWriter, "pointer",0);
        end;
        printCloseTagFunction(engine, "writeFunctionDec");
    end function;
    

    
    define function currentFunction(engine :: <compilation-engine>)
        if (engine.currentClass.size ~= 0 & engine.currentSubroutine.size ~= 0)
            values(concatenate(engine.currentClass,".",engine.currentSubroutine));
        else
            values("");
        end;
    end function;






/**
 * Compiles a single statement
 *
 */
define function compileStatement
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileStatement");
        //determine whether there is a statement_next can be a "}"
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        //next is a "}"
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), "}"))
            pointerBack(engine.tokenizer);
            printCloseTagFunction(engine, "compileStatement");
            return();
        end if;
        //next is 'let'|'if'|'while'|'do'|'return'
        if (type ~= #"KEYWORD")
            throwError(engine, "keyword");
            return();
        else
            select (getKeyword(engine.tokenizer))
                #"LET" => compileLet(engine);
                #"IF" => compileIf(engine);
                #"WHILE" => compilesWhile(engine);
                #"DO" => compileDo(engine);
                #"RETURN" => compileReturn(engine);
                otherwise => throwError(engine, "'let'|'if'|'while'|'do'|'return'"); return();
            end select;
        end;
        compileStatement(engine);
        printCloseTagFunction(engine, "compileStatement");
    end;
end function;


/**
 * Compiles a (possibly empty) parameter list
 * not including the enclosing "()"
 * ((type varName)(',' type varName)*)?
 */
define function compileParameterList
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileParameterList");
        //check if there is parameterList, if next token is ')' than go back
        advance(engine.tokenizer);
        if (engine.tokenizer.currentTokenType == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), ")"))
            pointerBack(engine.tokenizer);
            printCloseTagFunction(engine, "compileParameterList");
            return();
        end if;

        //there is parameter, at least one varName
        pointerBack(engine.tokenizer);
        while (#t)
            //type
            let type = compileType(engine);

            //varName
            advance(engine.tokenizer);
            if (engine.tokenizer.currentTokenType ~= #"IDENTIFIER")
                throwError(engine, "identifier");
                return();
            end if;

            defineId(engine.symbolTable, getIdentifier(engine.tokenizer), type, #"ARG");

            //',' or ')'
            advance(engine.tokenizer);
            let symbol = getSymbol(engine.tokenizer);
            if (engine.tokenizer.currentTokenType ~= #"SYMBOL" | (~string-equal?(symbol,",") & ~string-equal?(symbol,")")))
                throwError(engine, "',' or ')'");
                return();
            end if;
            if (engine.tokenizer.currentTokenType  == #"SYMBOL" & string-equal?(symbol, ")"))
                pointerBack(engine.tokenizer);
                return();
            end;
        end while;
    end;
        printCloseTagFunction(engine, "compileParameterList");
end function;

/**
 * Compiles a var declaration
 * 'var' type varName (',' varName)*
 */
define function compileVarDec
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileVarDec");
        //determine if there is a varDec
        advance(engine.tokenizer);
        //no 'var' go back
        if (engine.tokenizer.currentTokenType ~= #"KEYWORD" | getKeyword(engine.tokenizer) ~= #"VAR")
            pointerBack(engine.tokenizer);
            printCloseTagFunction(engine, "compileVarDec");
            return();
        end if;
        //type
        let type = compileType(engine);
        //at least one varName
        //boolean varNamesDone = false
        let flag = #t;
        while (flag)
            //varName
            advance(engine.tokenizer);
            if (engine.tokenizer.currentTokenType ~= #"IDENTIFIER")
                throwError(engine, "identifier");
                return();
            end if;
            defineId(engine.symbolTable, getIdentifier(engine.tokenizer), type, #"VAR");
            //',' or ';'
            advance(engine.tokenizer);
            type := engine.tokenizer.currentTokenType;
            let symbol = getSymbol(engine.tokenizer);
            if (type ~= #"SYMBOL" | (~string-equal?(symbol,",") & ~string-equal?(symbol,";")))
                throwError(engine, "',' or ';'");
                return();
            end if;
            if (string-equal? (getSymbol(engine.tokenizer), ";"))
                flag := #f;
            end if;
        end while;
        
        compileVarDec(engine);
        printCloseTagFunction(engine, "compileVarDec");
    end;
end function;

    /**
     * Compiles a do statement
     * 'do' subroutineCall ';'
     */
    define function compileDo(engine :: <compilation-engine>)
        printOpenTagFunction(engine, "compileDo");
        //subroutineCall
        compileSubroutineCall(engine);
        //';'
        requireSymbol(engine, ";");
        write-pop(engine.vmWriter, "temp", 0);
        printCloseTagFunction(engine, "compileDo");
    end function;

/**
 * Compiles a let statement
 * 'let' varName ('[' ']')? '=' expression ';'
 */
define function compileLet
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileLet");        
        //varName
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type ~= #"IDENTIFIER")
            throwError(engine, "varName");
            return();
        end if;
        let varName :: <string> = engine.tokenizer.currentToken;
        //'[' or '='
        advance(engine.tokenizer);
        type := engine.tokenizer.currentTokenType;
        let symbol = getSymbol(engine.tokenizer);
        if (type ~= #"SYMBOL" | (~string-equal?(symbol,"[") & ~string-equal?(symbol,"=")))
            throwError(engine, "'['|'='");
            return();
        end if;

        let arrayExist = #f;
        //'[' expression ']'
        if (string-equal? (getSymbol(engine.tokenizer), "["))
            arrayExist := #t;
            //push array variable, base address of array into stack
            write-push(engine.vmWriter, getSeg(engine, kindOf(engine.symbolTable, varName)),indexOf(engine.symbolTable, varName));
            //calc offset
            compileExpression(engine);
            //']'
            requireSymbol(engine, "]");
            //base+offset
            write-arithmetic(engine.vmWriter, "add");
            //=
            requireSymbol(engine, "=");

        end if;
        
        //expression
        compileExpression(engine);
        //';'
        requireSymbol(engine, ";");
        
        if (arrayExist)
            //*(base+offset) = expression
            //pop expression value to temp
            write-pop(engine.vmWriter, "temp", 0);
            //pop base+index into 'that'
            write-pop(engine.vmWriter, "pointer", 1);
            //pop expression value into *(base+index)
            write-push(engine.vmWriter, "temp", 0);
            write-pop(engine.vmWriter, "that",0);
        else
            //pop expression value directly
            let seg = getSeg(engine, kindOf(engine.symbolTable, varName));
            let idx = indexOf(engine.symbolTable, varName);
            write-pop(engine.vmWriter, seg, idx);
        end;
        printCloseTagFunction(engine, "compileLet");
    end;
end function;

    /**
     * Compiles a while statement
     * 'while' '(' expression ')' "{" statements "}"
     */
    define function compilesWhile(engine :: <compilation-engine>)
        printOpenTagFunction(engine, "compilesWhile");
        let continueLabel = newLabel(engine);
        let topLabel = newLabel(engine);
        //top label for while loop
        write-label(engine.vmWriter, topLabel);
        //'('
        requireSymbol(engine, "(");
        //expression while condition: true or false
        compileExpression(engine);
        //')'
        requireSymbol(engine, ")");
        //if ~(condition) go to continue label
        write-arithmetic(engine.vmWriter, "not");
        write-if(engine.vmWriter, continueLabel);
        //"{"
        requireSymbol(engine, "{");
        //statements
        compileStatement(engine);
        //"}"
        requireSymbol(engine, "}");
        
        //if (condition) go to top label
        write-goto(engine.vmWriter, topLabel);
        //or continue
        write-label(engine.vmWriter, continueLabel);
        printCloseTagFunction(engine, "compilesWhile");
    end function;

/**
 * Compiles a return statement
 * ‘return’ expression? ';'
 */
define function compileReturn
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileReturn");     
        //check if there is any expression
        advance(engine.tokenizer);
        //no expression
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), ";"))
            //no expression, push 0 to stack
            write-push(engine.vmWriter, "constant", 0)
        else
            pointerBack(engine.tokenizer);
            //expression
            compileExpression(engine);
            //';'
            requireSymbol(engine, ";");
        end;
        write-return(engine.vmWriter);
        printCloseTagFunction(engine, "compileReturn");
    end;
end function;

    /**
     * Compiles an if statement
     * possibly with a trailing else clause
     * 'if' '(' expression ')' "{" statements "}" ('else' "{" statements "}")?
     */
    define function compileIf(engine :: <compilation-engine>)
        printOpenTagFunction(engine, "compileIf");
        let elseLabel = newLabel(engine);
        let endLabel = newLabel(engine);
        
        //'('
        requireSymbol(engine, "(");
        //expression
        compileExpression(engine);
        //')'
        requireSymbol(engine, ")");
        //if ~(condition) go to else label
        write-arithmetic(engine.vmWriter, "not");
        write-if(engine.vmWriter, elseLabel);
        //"{"
        requireSymbol(engine, "{");
        //statements
        compileStatement(engine);        
        //"}"
        requireSymbol(engine, "}");
        //if condition after statement finishing, go to end label
        write-goto(engine.vmWriter, endLabel);
        write-label(engine.vmWriter, elseLabel);
        //check if there is 'else'
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type == #"KEYWORD" & getKeyword(engine.tokenizer) == #"ELSE")
            
            //"{"
            requireSymbol(engine, "{");
            //statements
            compileStatement(engine);
            //"}"
            requireSymbol(engine, "}");
        else
            pointerBack(engine.tokenizer);
        end;
        
        write-label(engine.vmWriter, endLabel);
        printCloseTagFunction(engine, "compileIf");
    end function;


/**
 * Compiles a term.
 * This routine is faced with a slight difficulty when trying to decide between some of the alternative parsing rules.
 * Specifically, if the current token is an identifier
 * the routine must distinguish between a variable, an array entry and a subroutine call
 * A single look-ahead token, which may be one of "[" "(" "." suffices to distinguish between the three possibilities
 * Any other token is not part of this term and should not be advanced over
 *
 * integerConstant|stringConstant|keywordConstant|varName|varName '[' expression ']'|subroutineCall|
 * '(' expression ')'|unaryOp term
 */
define function compileTerm
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileTerm");
        advance(engine.tokenizer);
        //check if it is an identifier
        let type1 = engine.tokenizer.currentTokenType;
        if (type1 == #"IDENTIFIER")
            //varName|varName '[' expression ']'|subroutineCall
            let token1 = engine.tokenizer.currentToken;
            advance(engine.tokenizer);
            let type2 = engine.tokenizer.currentTokenType;
            let token2 = engine.tokenizer.currentToken;
            if (type2 == #"SYMBOL" & (string-equal?(token2,"(") | string-equal?(token2,".")))
                //this is a subroutineCall
                pointerBack(engine.tokenizer);
                pointerBack(engine.tokenizer);
                compileSubroutineCall(engine);
            else
                //this is an array entry or varName <=> varName|varName '[' expression ']'
                //if this is an array entry push array variable, base address into stack
                //if this is varName push variable directly onto stack
                let seg = getSeg(engine, kindOf(engine.symbolTable, token1));
                let idx = indexOf(engine.symbolTable, token1);
                write-push(engine.vmWriter, seg, idx);
                if (type2 == #"SYMBOL" & string-equal? (token2, "["))
                    //this is an array entry <=> varName '[' expression ']'
                    //expression
                    compileExpression(engine);
                    //"]"
                    requireSymbol(engine, "]");
                    //base+offset
                    write-arithmetic(engine.vmWriter, "add");
                    //pop into 'that' pointer
                    write-pop(engine.vmWriter, "pointer",1);
                    //push *(base+index) onto stack
                    write-push(engine.vmWriter, "that",0);
                else
                    pointerBack(engine.tokenizer); // this is varName
                end;
            end;
        else
            let symbol = getSymbol(engine.tokenizer);
            //integerConstant|stringConstant|keywordConstant|'(' expression ')'|unaryOp term
            if (type1 == #"INT_CONST")
                let idx = getIntVal(engine.tokenizer);
                write-push(engine.vmWriter, "constant", idx);
            elseif (type1 == #"STRING_CONST")
                let str = getStringVal(engine.tokenizer);
                write-push(engine.vmWriter,  "constant", str.size);
                write-call(engine.vmWriter, "String.new",1);
                for (ch in str)
                    write-push(engine.vmWriter, "constant",  (as(<integer>, ch)));
                    write-call(engine.vmWriter, "String.appendChar",2);
                end for;

            elseif (type1 == #"KEYWORD")
                select (getKeyword(engine.tokenizer))
                    #"TRUE" => 
                        write-push(engine.vmWriter, "constant", 0);
                        write-arithmetic(engine.vmWriter, "not");
                    #"THIS" =>
                        write-push(engine.vmWriter, "pointer", 0);
                     #"FALSE", #"NULL" => 
                        write-push(engine.vmWriter, "constant", 0);
                end select;
            elseif (type1 == #"SYMBOL" & string-equal?(symbol, "("))
                //expression
                compileExpression(engine);
                //")"
                requireSymbol(engine, ")");
            elseif (type1 == #"SYMBOL" & (string-equal?(symbol,"-") | string-equal?(symbol,"~")))
                //term
                compileTerm(engine);
                if (string-equal?(symbol,"-"))
                    write-arithmetic(engine.vmWriter, "neg");
                else
                    write-arithmetic(engine.vmWriter, "not");
                end;
            else
                throwError(engine, "integerConstant|stringConstant|keywordConstant|'(' expression ')'|unaryOp term");
                return();
            end;
            
        end;
    end;
    printCloseTagFunction(engine, "compileTerm");
end function;

/**
 * Compiles a subroutine call
 * subroutineName '(' expressionList ')' | (className|varName) '.' subroutineName '(' expressionList ')'
 */
define function compileSubroutineCall
(engine :: <compilation-engine>)
    block (return)
        printOpenTagFunction(engine, "compileSubroutineCall");
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type ~= #"IDENTIFIER")
            throwError(engine, "identifier");
            return();
        end if;
        
        let name = getIdentifier(engine.tokenizer);
        let nArgs = 0;
        advance(engine.tokenizer);
        type := engine.tokenizer.currentTokenType;
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), "("))
            write-push(engine.vmWriter, "pointer", 0);
            //'(' expressionList ')'
            //expressionList
            nArgs := compileExpressionList(engine) + 1;

            //')'
            requireSymbol(engine, ")");
            //call subroutine
            write-call(engine.vmWriter, concatenate(engine.currentClass,".",name), nArgs);

        elseif (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), "."))
            //(className|varName) '.' subroutineName '(' expressionList ')'
            let objName = name;            
            //subroutineName
            advance(engine.tokenizer);
            type := engine.tokenizer.currentTokenType;
            if (type ~= #"IDENTIFIER")
                throwError(engine, "identifier");
                return();
            end if;

            name := getIdentifier(engine.tokenizer);
            //check for if it is built-in type
            let symbolType = typeOf(engine.symbolTable, objName);

            if (member?(symbolType, #["int","boolean","char","void"]))
                throwError(engine, "no built-in type");
            elseif (~symbolType)
                //הפונקציה מהצורה: MyClass.Func(x,y) או מהצורה: OtherClass.Func(x,y)
                //כלומר, או שהיא פונקציה סטטית של המחלקה הנוכחית, או שהיא פונקציה סטטית של מחלקה אחרת
                name := concatenate(objName,".",name);
            else
                //הפונקציה מהצורה: Obj.Func(x,y) <=>
                //הפונקציה היא method של מחלקה אחרת, כלומר אוכל לקבל מטבלת הסמלים את הטיפוס שלה
                //push variable directly onto stack
                write-push(engine.vmWriter, getSeg(engine, kindOf(engine.symbolTable, objName)), indexOf(engine.symbolTable, objName));
                nArgs := 1;
                name := concatenate(symbolType,".",name);
            end;
            
            //'('
            requireSymbol(engine, "(");
            //expressionList
            nArgs := nArgs + compileExpressionList(engine);
            //')'
            requireSymbol(engine, ")");
            //call subroutine
            write-call(engine.vmWriter, name, nArgs);
        else
            throwError(engine, "'('|'.'");
            return();
        end;
        printCloseTagFunction(engine, "compileSubroutineCall");
    end;
end function;
    

    /**
     * Compiles an expression
     * term (op term)*
     */
    define function compileExpression(engine :: <compilation-engine>)
        printOpenTagFunction(engine, "compileExpression");
        //term
        compileTerm(engine);
        //(op term)*
        block (break)
            while (#t)
                advance(engine.tokenizer);
                //op
                let type :: <token-type> = engine.tokenizer.currentTokenType;
                
                if (type == #"SYMBOL" & isOp(engine.tokenizer))
                    let opCmd = "";
                    block (break)
                        select (getSymbol(engine.tokenizer) by \=)
                            "+" => opCmd := "add"; break();
                            "-" => opCmd := "sub"; break();
                            "*" => opCmd := "call Math.multiply 2"; break();
                            "/" => opCmd := "call Math.divide 2"; break();
                            "<" => opCmd := "lt"; break();
                            ">" => opCmd := "gt"; break();
                            "=" => opCmd := "eq"; break();
                            "&" => opCmd := "and"; break();
                            "|" => opCmd := "or"; break();
                            otherwise => throwError(engine, "Unknown op!"); break();
                        end select;
                    end;

                    //term
                    compileTerm(engine);
                    writeCommand(engine.vmWriter, opCmd);
                else
                    pointerBack(engine.tokenizer);
                    break();
                end;
            end while;
        end;
        printCloseTagFunction(engine, "compileExpression");
    end function;



    /**
     * Compiles a (possibly empty) comma-separated list of expressions
     * (expression(','expression)*)?
     */
    define function compileExpressionList(engine :: <compilation-engine>)
        printOpenTagFunction(engine, "compileExpressionList");        
        let nArgs = 0;
        advance(engine.tokenizer);
        //determine if there is any expression, if next is ')' then no
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), ")"))
            pointerBack(engine.tokenizer);
        else
            nArgs := 1;
            pointerBack(engine.tokenizer);
            //expression
            compileExpression(engine);
            //(','expression)*
            let flag = #t;
            while (flag)
                advance(engine.tokenizer);
                type := engine.tokenizer.currentTokenType;
                if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer), ","))
                    //expression
                    compileExpression(engine);
                    nArgs := nArgs + 1;
                else
                    pointerBack(engine.tokenizer);
                    flag := #f;
                end;
            end while;
        end if;

        printCloseTagFunction(engine, "compileExpressionList");
        values(nArgs);        
    end function;

    //---------------------------------Auxiliary functions---------------------------------//



    define function getSeg(engine :: <compilation-engine>, kind :: <kind>)
        printOpenTagFunction(engine, "getSeg");
        let mySegment = #"NONE";
        let mySegment = select (kind)
            #"FIELD" => #"THIS";
            #"STATIC" => #"STATIC";
            #"VAR" => #"LOCAL";
            #"ARG" => #"ARGUMENT";
            otherwise => #"NONE";
        end select;
        printCloseTagFunction(engine, "getSeg");
        as(<string>, mySegment);
    end function;




define function newLabel
(engine :: <compilation-engine>)
    let res = concatenate("LABEL_", integer-to-string(engine.labelIndex));
    engine.labelIndex := engine.labelIndex + 1;
    values(res);
end function;

/**
 * require symbol when we know there must be such symbol
 * @param symbol
 */
define function requireSymbol
(engine :: <compilation-engine>, symbol :: <string>)
    block (return)
      
        advance(engine.tokenizer);
        let type :: <token-type> = engine.tokenizer.currentTokenType;
        if (type == #"SYMBOL" & string-equal? (getSymbol(engine.tokenizer),symbol))
            
        else 
            throwError(engine, symbol);
            return();
        end;
    end;
end function;


    /**
     * throw an exception to report throwErrors
     * @param val is expected token missing
     */
    define function throwError(engine :: <compilation-engine>, val :: <string>)
        format-out(concatenate("Expected token missing: ",val,". Current token: ", engine.tokenizer.currentToken));
        force-out();
    end function;






    //--------------------------------- Only For Debugging! ---------------------------------//

        define function printOpenTagFunction(engine :: <compilation-engine>, tag :: <string>)
        for (i from 1 to engine.indentation)
            format-out(engine.width);
        end for;
        engine.indentation := engine.indentation + 1;
        format-out(concatenate("<",tag,">\n"));
        force-out();
    end function;


    define function printCloseTagFunction(engine :: <compilation-engine>, tag :: <string>)
        engine.indentation := engine.indentation - 1;
        for (i from 1 to engine.indentation)
            format-out(engine.width);
        end for;
        format-out(concatenate("<",tag,"/>\n"));
        force-out();
    end function;